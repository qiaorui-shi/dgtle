<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      .container {
        width: 400px;
        margin: 0 auto;
        background: pink;
        padding: 20px;
      }

      .list {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        padding: 10px;
        touch-action: none;
      }

      .list-item {
        width: 100px;
        height: 100px;
        border: 1px solid #000;
        background: #fff;
        line-height: 100px;
        text-align: center;
        list-style: none;
        user-select: none;
      }

      .active {
        background: skyblue;
      }

      .clone-item {
        position: fixed;
        left: 0;
        top: 0;
        z-index: 1;
        width: 100px;
        height: 100px;
        border: 1px solid #000;
        background: #fff;
        line-height: 100px;
        text-align: center;
        list-style: none;
        user-select: none;
        pointer-events: none;
        opacity: 0.8;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <ul class="list">
        <li class="list-item">111</li>
        <li class="list-item">222</li>
        <li class="list-item">333</li>
        <li class="list-item">444</li>
        <li class="list-item">555</li>
        <li class="list-item">666</li>
        <li class="list-item">777</li>
        <li class="list-item">888</li>
        <li class="list-item">999</li>
      </ul>
    </div>

    <script>
      class Draggable {
        containerElement = null; // 拖拽容器元素
        rectList = []; // 存储容器内每个项的边界矩形信息
        isPointerDown = false; // 标记是否按下鼠标
        drag = { element: null, index: 0, firstIndex: 0 }; // 存储正在拖动的元素及其索引
        clone = { element: null, x: 0, y: 0 }; // 克隆元素，用来展示拖拽效果
        diff = { x: 0, y: 0 }; // 拖动时与上次位置的差值
        referenceElement = null; // 存储参考元素，用于插入拖动元素的位置
        lastPointerMove = { x: 0, y: 0 }; // 上一次的指针位置

        constructor(options) {
          this.containerElement = options.element; // 拖拽容器元素
          this.init();
        }

        // 初始化拖拽功能
        init() {
          this.getRectList(); // 计算每个项的边界矩形
          this.bindEventListener(); // 绑定事件监听器
        }

        // 更新每个拖拽项的矩形位置
        getRectList() {
          this.rectList.length = 0;
          for (const item of this.containerElement.children) {
            this.rectList.push(item.getBoundingClientRect());
          }
        }

        // 处理 pointerdown 事件，开始拖动
        onPointerDown(e) {
          if (e.pointerType === "mouse" && e.button !== 0) {
            return; // 只允许鼠标左键点击
          }
          if (e.target === this.containerElement) {
            return; // 如果点击的是容器本身，不做处理
          }

          this.isPointerDown = true; // 开始拖动

          this.containerElement.setPointerCapture(e.pointerId); // 捕获指针事件

          this.lastPointerMove.x = e.clientX; // 记录初始位置
          this.lastPointerMove.y = e.clientY;

          this.drag.element = e.target; // 当前拖动的元素
          this.drag.element.classList.add("active"); // 添加样式，表示正在拖动

          const index = [].indexOf.call(this.containerElement.children, this.drag.element); // 获取当前拖动元素的索引
          this.drag.index = index;
          this.drag.firstIndex = index;

          this.clone.x = this.rectList[index].left; // 获取元素的初始位置
          this.clone.y = this.rectList[index].top;

          this.clone.element = this.drag.element.cloneNode(true); // 克隆元素
          document.body.appendChild(this.clone.element); // 将克隆元素添加到文档中

          this.clone.element.style.transition = "none"; // 禁用过渡效果，立即显示
          this.clone.element.className = "clone-item"; // 设置克隆元素的类名
          this.clone.element.style.transform = `translate3d(${this.clone.x}px, ${this.clone.y}px, 0)`; // 设置初始位置

          // 所有容器内的项都设置过渡效果
          for (const item of this.containerElement.children) {
            item.style.transition = "transform 500ms";
          }
        }

        // 处理 pointermove 事件，更新拖动位置
        onPointerMove(e) {
          if (this.isPointerDown) {
            this.diff.x = e.clientX - this.lastPointerMove.x; // 计算指针的偏移量
            this.diff.y = e.clientY - this.lastPointerMove.y;

            this.lastPointerMove.x = e.clientX; // 更新当前位置
            this.lastPointerMove.y = e.clientY;

            this.clone.x += this.diff.x; // 更新克隆元素位置
            this.clone.y += this.diff.y;

            // 更新克隆元素的 transform 样式
            this.clone.element.style.transform = `translate3d(${this.clone.x}px, ${this.clone.y}px, 0)`;

            // 遍历每个项，判断是否需要交换位置
            for (let i = 0; i < this.rectList.length; i++) {
              if (i !== this.drag.index && e.clientX > this.rectList[i].left && e.clientX < this.rectList[i].right && e.clientY > this.rectList[i].top && e.clientY < this.rectList[i].bottom) {
                if (this.drag.index < i) {
                  for (let j = this.drag.index; j < i; j++) {
                    if (j < this.drag.firstIndex) {
                      this.containerElement.children[j].style.transform = "translate3d(0px, 0px, 0)";
                    } else {
                      const x = this.rectList[j].left - this.rectList[j + 1].left;
                      const y = this.rectList[j].top - this.rectList[j + 1].top;
                      this.containerElement.children[j + 1].style.transform = `translate3d(${x}px, ${y}px, 0)`;
                    }
                  }
                  this.referenceElement = this.containerElement.children[i + 1]; // 设置参考元素
                } else if (this.drag.index > i) {
                  for (let j = i; j < this.drag.index; j++) {
                    if (this.drag.firstIndex <= j) {
                      this.containerElement.children[j + 1].style.transform = "translate3d(0px, 0px, 0)";
                    } else {
                      const x = this.rectList[j + 1].left - this.rectList[j].left;
                      const y = this.rectList[j + 1].top - this.rectList[j].top;
                      this.containerElement.children[j].style.transform = `translate3d(${x}px, ${y}px, 0)`;
                    }
                  }
                  this.referenceElement = this.containerElement.children[i]; // 更新参考元素
                }
                const x = this.rectList[i].left - this.rectList[this.drag.firstIndex].left;
                const y = this.rectList[i].top - this.rectList[this.drag.firstIndex].top;
                this.drag.element.style.transform = `translate3d(${x}px, ${y}px, 0)`; // 更新被拖动元素的位置
                this.drag.index = i; // 更新拖动元素的索引
                break;
              }
            }
          }
        }

        // 处理 pointerup 事件，完成拖动
        onPointerUp(e) {
          if (this.isPointerDown) {
            this.isPointerDown = false;

            this.drag.element.classList.remove("active"); // 移除拖动样式
            this.clone.element.remove(); // 移除克隆元素

            // 重置每个项的过渡效果和位置
            for (const item of this.containerElement.children) {
              item.style.transition = "none";
              item.style.transform = "translate3d(0px, 0px, 0px)";
            }

            // 如果参考元素存在，执行插入操作
            if (this.referenceElement !== null) {
              this.containerElement.insertBefore(this.drag.element, this.referenceElement);
            }
          }
        }

        // 绑定事件监听器 使用bind保持this指向当前类实例
        bindEventListener() {
          this.containerElement.addEventListener("pointerdown", this.onPointerDown.bind(this));
          this.containerElement.addEventListener("pointermove", this.onPointerMove.bind(this));
          this.containerElement.addEventListener("pointerup", this.onPointerUp.bind(this));

          // 监听窗口滚动、大小变化等事件，更新矩形列表
          window.addEventListener("scroll", this.getRectList.bind(this));
          window.addEventListener("resize", this.getRectList.bind(this));
          window.addEventListener("orientationchange", this.getRectList.bind(this));
        }
      }

      // 初始化 Draggable 实例
      new Draggable({
        element: document.querySelector(".list") // 设置拖拽容器元素
      });
    </script>
  </body>
</html>
